# JavaScript Best Practice Guide.
*В этой статье мы рассмотрим лучшие практики и методы стилизации кода, чтобы сделать его более понятным и легко читаемым. Мы рассмотрим подход к именованию переменных и функций, призовём себя к избеганию использования глобальных переменных, сохранению строгого стиля программирования и комментирования кода.*
***
### 1. Простые и понятные имена переменных, функций и классов.

**Названия функций должны быть краткими и содержательными.** Например, если мы хотим создать переменную для хранения чьего-то дня рождения, она должна иметь имя, явно указывающее на это.

Это означает, что не должно быть имён типа `b`, также как и не должно быть излишне громоздкое и перенасыщенное посторонними словами вроде `soVeryUselessLongBirthdayVariable`. Было бы уместно назвать его просто `birthday`.

**Также рекомендуется хранить имена на английском языке,** так как это сохраняет консистентность стиля в соответствии с остальным кодом. Все зарезервированные слова, такие как `function` и `new` - всё на английском языке, так что всё остальное должно быть на английском.
Английский также более интернациональный язык, так что вероятность больше, что разработчики знают английский язык, и смогут прочитать ваш код.

Классы - это функции, которые создают другие объекты, поэтому их названия должны отражать это. Например, если у нас есть класс, который создаёт объект человека, то он должны быть названы как `Person`.
Имена классов должны быть в верхнем регистре и указывать, какой именно объект мы из него создаём.

### 2. Избегайте частого использования глобальных переменных и функций.

В JavaScript всё запускается в одной и той же области видимости. И это реальная проблема, потому что некоторые данные могут быть случайно изменены в одной части кода, которая повлияет на другой код, использующий эти же данные.

К счастью, начиная с ES6, JavaScript имеет несколько возможностей для решения этой проблемы. Одна из них - **использование модулей**. С модулями, только то, что мы явно экспортируем, доступно для использования другими модулями.
Также **должен быть включен строгий режим JavaScript,** чтобы предотвратить случайное объявление глобальных переменных. При строгом режиме что-то вроде `x = 1` приведет к ошибке без ключевых слов `var`, `let` или `const` перед ней.

Также `let` и `const` являются ключевыми словами для объявления локальных переменных и констант соответственно, поэтому мы не можем случайно ссылаться на них за пределами видимости блока, в котором они были объявлены.

Например, с `var`, если мы пишем следующий код:
``` js
if (true) {
  var x = 1;
}
```
Выполнив этот пример, вызвав `console.log`, мы увидим результат `1`. Это всё из-за того, что объявление переменной через `var` применяется к глобальной области видимости.

В другом же случае, если мы используем `let` вместо `var`:
``` js
if (true) {
  let x = 1;
}
console.log(x);
```
В результате мы получаем ошибку 'Uncaught ReferenceError: x is not defined'.
Как мы видим, мы не можем обращаться к переменным, которые доступны только в ограниченной области видимости (в данном случае, области видимости функции).

Альтернативным способом решения этой проблемы - можно обернуть в вызов функции код, который мы хотим сделать приватным.

Например, мы можем написать:
``` js
(function() {
  var x = 1;
})();
console.log(x);
```
И тут мы также мы получим ошибку 'Uncaught ReferenceError: x is not defined'. Функция, которая запускается сразу же после объявления, как показано выше, называется IIFE (Immediately Invoked Function Expression) "Функция немедленного вызова".
Если мы хотим вернуть что-то из этой функции другому коду, который у нас есть выше, мы можем просто вернуть данные следующим образом:
``` js
let foo = (function() {
  var x = 1;
  return {
    bar: 2
  }
})();
console.log(foo.bar);
```
Мы вернули объект со свойством `bar` и присвоили его переменной `foo`. И, в результате, мы должны получить 2 из вывода `console.log`.

### 3. Следуйте строгому стиль программирования.
Каждый разработчик в команде будет иметь свой индивидуальный стиль кодинга, которому пожелает следовать, при стилизации своего кода. Это означает, что код будет иметь разные стили в разных местах, где работали разные программисты, что усложняет чтение кода другими разработчиками. В связи с этим, неплохо было бы следовать какому-то общему формату стилей. Мы можем стилизовать наш код автоматически с помощью таких программ, как `ESLint` или `JSLint`, которые осуществляют статическую проверку нашего кода, чтобы убедиться, что он соответствует установленному стилю.

Есть также такие инструменты, как `Prettier`, для последовательного форматирования кода посредством стиля кода нашего приложения.

**Чистый код легко читается и поддерживается.** В нем не должно быть халтурных вещей, которые делают его трудным для чтения или отладки.

### 4. Комментарий при необходимости.

Если мы пишем комментарии, то следует использовать многострочные комментарии `/* */` вместо однострочных `//`, так как они более универсальны.

Один из удобных приемов комментирования заключается в том, что перед закрытием многострочных комментариев нужно добавить двойной слеш следующим образом:
``` js
`/*`
  function foo(){
    return 1
  };  
`// */`
```
Таким образом, мы можем **раскомментировать код, поставив слеш** перед открывающим слешем в первой строке. И, чтобы раскомментировать код, достаточно:
``` js
`//*`
  function foo(){
    return 1
  };  
`// */`
```
Вышеуказанный код раскомментирован.

Многие текстовые редакторы также должны быть достаточно умны, чтобы автоматически распознавать и подсвечивать закомментированный и раскомментированный JavaScript-код.

### 5. Не использовать new Object ().

Используйте `{}`вместо`new Object()`
Используйте `""`вместо`new String()`
Используйте `0`вместоnew Number()
Используйте `false`вместо`new Boolean()`
Используйте `[]`вместо`new Array()`
Используйте `/()/`вместо`new RegExp()`
Используйте `function (){}`вместо`new Function()`
пример
``` js
var x1 = {};           `// new object`
var x2 = "";           `// new primitive string`
var x3 = 0;            `// new primitive number`
var x4 = false;        `// new primitive boolean`
var x5 = [];           `// new array object`
var x6 = /()/;         `// new regexp object`
var x7 = function(){}; `// new function object`
```
### 6. Объявления сверху.

Хорошая практика программирования - помещать все объявления вверху каждого скрипта или функции.

Это будет:

+Дайте более чистый код
+Обеспечьте единое место для поиска локальных переменных
+Упростите избежание нежелательных (подразумеваемых) глобальных переменных
+Уменьшите вероятность нежелательных повторных деклараций

``` js
`// Declare at the beginning`
var firstName, lastName, price, discount, fullPrice;

`// Use later`
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price - discount;
```
Это также касается переменных цикла:
``` js
`// Declare at the beginning`
var i;

`// Use later`
for (i = 0; i < 5; i++) {}
```

### 7. Используйте === Сравнение.

Оператор `==`сравнения всегда преобразуется (в соответствующие типы) перед сравнением.

`===`Оператор силы Сравнение значений и типов:

пример
``` js
0 == "";        `// true`
1 == "1";       `// true`
1 == true;      `// true`

0 === "";       `// false`
1 === "1";      `// false`
1 === true;     `// false`
```

### 8. Использовать значения параметров по умолчанию.

Если функция вызывается с отсутствующим аргументом, значение отсутствующего аргумента устанавливается равным `undefined`.

Неопределенные значения могут нарушить ваш код. Присваивать аргументам значения по умолчанию - хорошая привычка.

пример
``` js
function myFunction(x, y) {
  if (y === undefined) {
    y = 0;
  }
}
```

### 9. Завершите свои переключатели настройками по умолчанию.

Всегда заканчивайте свои `switch`утверждения расширением `default`. Даже если вы думаете, что в этом нет необходимости.

пример
``` js
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
    break;
  default:
    day = "Unknown";
}
```

### 10. Остерегайтесь автоматического преобразования типов.
Помните, что числа могут быть случайно преобразованы в строки или `NaN`(не число).

JavaScript слабо типизирован. Переменная может содержать разные типы данных, а переменная может изменять свой тип данных:

пример
``` js
var x = "Hello";     `// typeof x is a string`
x = 5;               `// changes typeof x to a number`
```
При выполнении математических операций JavaScript может преобразовывать числа в строки:

пример
``` js
var x = 5 + 7;       `// x.valueOf() is 12,  typeof x is a number`
var x = 5 + "7";     `// x.valueOf() is 57,  typeof x is a string`
var x = "5" + 7;     `// x.valueOf() is 57,  typeof x is a string`
var x = 5 - 7;       `// x.valueOf() is -2,  typeof x is a number`
var x = 5 - "7";     `// x.valueOf() is -2,  typeof x is a number`
var x = "5" - 7;     `// x.valueOf() is -2,  typeof x is a number`
var x = 5 - "x";     `// x.valueOf() is NaN, typeof x is a number`
```

И вот они все и есть, **лучшие JavaScript практики** по комментированию, именованию и стилю написания кода.
